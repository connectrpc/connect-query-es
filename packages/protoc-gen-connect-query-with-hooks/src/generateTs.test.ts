// Copyright 2021-2022 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import type { Target } from '@bufbuild/protoplugin/ecmascript';
import { describe, expect, it } from '@jest/globals';

import packageJson from '../package.json';
import { generate } from './jest/helpers';

describe('generateTs', () => {
  const expected = (target: Target) => [
    '// Copyright 2021-2022 Buf Technologies, Inc.',
    '//',
    '// Licensed under the Apache License, Version 2.0 (the "License");',
    '// you may not use this file except in compliance with the License.',
    '// You may obtain a copy of the License at',
    '//',
    '//      http://www.apache.org/licenses/LICENSE-2.0',
    '//',
    '// Unless required by applicable law or agreed to in writing, software',
    '// distributed under the License is distributed on an "AS IS" BASIS,',
    '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.',
    '// See the License for the specific language governing permissions and',
    '// limitations under the License.',
    '',
    `// @generated by protoc-gen-connect-query-with-hooks v${packageJson.version} with parameter "target=${target},import-hook-from=@tanstack/react-query"`,
    '// @generated from file eliza.proto (package buf.connect.demo.eliza.v1, syntax proto3)',
    '/* eslint-disable */',
    '// @ts-nocheck',
    '',
    "import { say, sayAgain } from \"./eliza-ElizaService_connectquery.ts\";",
    "import { UseBaseQueryOptions, useInfiniteQuery, UseInfiniteQueryOptions, useMutation, UseMutationOptions, useQuery } from \"@tanstack/react-query\";",
    "import { PartialMessage } from \"@bufbuild/protobuf\";",
    "import { SayRequest, SayResponse } from \"./eliza_pb.js\";",
    "import { ConnectError } from \"@bufbuild/connect\";",
    "",
    "/**",
    " * Say is a unary request demo. This method should allow for a one sentence",
    " * response given a one sentence request.",
    " *",
    " * @generated from rpc buf.connect.demo.eliza.v1.ElizaService.Say",
    " */",
    "export const useSayQuery = ",
    "  ({",
    "    inputs,",
    "    transformParams,",
    "  }: {",
    "    inputs: Parameters<typeof say.useQuery>;",
    "    transformParams?: (",
    "      baseOptions: ReturnType<typeof say.useQuery>",
    "    ) => Partial<UseBaseQueryOptions<PartialMessage<SayRequest>, ConnectError>>;",
    "  }) => {",
    "    const baseOptions = say.useQuery(...inputs);",
    "    let options = baseOptions;",
    "    if (transformParams) {",
    "      options = Object.assign({}, baseOptions, transformParams(baseOptions));",
    "    }",
    "",
    "    return useQuery(options);",
    "  };",
    "",
    "export const useSayMutation = ",
    "  ({",
    "    inputs,",
    "    transformParams,",
    "  }: {",
    "    inputs: Parameters<typeof say.useMutation>;",
    "    transformParams?: (",
    "      baseOptions: ReturnType<typeof say.useMutation>",
    "    ) => Partial<UseMutationOptions<PartialMessage<SayResponse>, ConnectError, PartialMessage<SayRequest>>>;",
    "  }) => {",
    "    const baseOptions = say.useMutation(...inputs);",
    "    let options = baseOptions;",
    "    if (transformParams) {",
    "      options = Object.assign({}, baseOptions, transformParams(baseOptions));",
    "    }",
    "",
    "    return useMutation(options);",
    "  };",
    "",
    "export const useSayInfiniteQuery = ",
    "  ({",
    "    inputs,",
    "    transformParams,",
    "  }: {",
    "    inputs: Parameters<typeof say.useInfiniteQuery>;",
    "    transformParams?: (",
    "      baseOptions: ReturnType<typeof say.useInfiniteQuery>",
    "    ) => Partial<UseInfiniteQueryOptions<PartialMessage<SayRequest>, ConnectError>>;",
    "  }) => {",
    "    const baseOptions = say.useInfiniteQuery(...inputs);",
    "    let options = baseOptions;",
    "    if (transformParams) {",
    "      options = Object.assign({}, baseOptions, transformParams(baseOptions));",
    "    }",
    "",
    "    return useInfiniteQuery(options);",
    "  };",
    "",
    "/**",
    " * Say is a unary request demo. This method should allow for a one sentence",
    " * response given a one sentence request.",
    " *",
    " * @generated from rpc buf.connect.demo.eliza.v1.ElizaService.SayAgain",
    " */",
    "export const useSayAgainQuery = ",
    "  ({",
    "    inputs,",
    "    transformParams,",
    "  }: {",
    "    inputs: Parameters<typeof sayAgain.useQuery>;",
    "    transformParams?: (",
    "      baseOptions: ReturnType<typeof sayAgain.useQuery>",
    "    ) => Partial<UseBaseQueryOptions<PartialMessage<SayRequest>, ConnectError>>;",
    "  }) => {",
    "    const baseOptions = sayAgain.useQuery(...inputs);",
    "    let options = baseOptions;",
    "    if (transformParams) {",
    "      options = Object.assign({}, baseOptions, transformParams(baseOptions));",
    "    }",
    "",
    "    return useQuery(options);",
    "  };",
    "",
    "export const useSayAgainMutation = ",
    "  ({",
    "    inputs,",
    "    transformParams,",
    "  }: {",
    "    inputs: Parameters<typeof sayAgain.useMutation>;",
    "    transformParams?: (",
    "      baseOptions: ReturnType<typeof sayAgain.useMutation>",
    "    ) => Partial<UseMutationOptions<PartialMessage<SayResponse>, ConnectError, PartialMessage<SayRequest>>>;",
    "  }) => {",
    "    const baseOptions = sayAgain.useMutation(...inputs);",
    "    let options = baseOptions;",
    "    if (transformParams) {",
    "      options = Object.assign({}, baseOptions, transformParams(baseOptions));",
    "    }",
    "",
    "    return useMutation(options);",
    "  };",
    "",
    "export const useSayAgainInfiniteQuery = ",
    "  ({",
    "    inputs,",
    "    transformParams,",
    "  }: {",
    "    inputs: Parameters<typeof sayAgain.useInfiniteQuery>;",
    "    transformParams?: (",
    "      baseOptions: ReturnType<typeof sayAgain.useInfiniteQuery>",
    "    ) => Partial<UseInfiniteQueryOptions<PartialMessage<SayRequest>, ConnectError>>;",
    "  }) => {",
    "    const baseOptions = sayAgain.useInfiniteQuery(...inputs);",
    "    let options = baseOptions;",
    "    if (transformParams) {",
    "      options = Object.assign({}, baseOptions, transformParams(baseOptions));",
    "    }",
    "",
    "    return useInfiniteQuery(options);",
    "  };"
  ];

  it('generates a full ts file', () => {
    const target = 'ts';
    const output = generate(target, '@tanstack/react-query')(
      `eliza-ElizaService_connectquery_hooks.${target}`,
    );
    expect(output).toStrictEqual(expected(target));
  });
});
